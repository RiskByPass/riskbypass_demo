import requests_go as requests
# -*- coding: utf-8 -*-
# Auto-generated by RiskByPass Task Panel
# Deps: pip install requests
import time, json, random
import base64
from urllib.parse import urlencode

BASE_URL = "https://riskbypass.com"  # API base URL
TOKEN    = "your token"    # Access token (sent as x-api-key)
TIMEOUT  = 60                         # Timeout (seconds)
PROXY = f'http://username:password@host:port'

def run_task(payload):
    session = requests.Session()
    headers = {"Content-Type": "application/json", "x-api-key": TOKEN}

    print("Submitting task…")

    try:
        resp = session.post(f"{BASE_URL}/task/submit", headers=headers, json=payload, timeout=30)
        resp.raise_for_status()
        data = resp.json()
    except Exception as e:
        print("Submit request error:", repr(e))
        return

    if not data.get("ok"):
        print("Submit failed:", data)
        return

    task_id = data.get("task_id")
    if not task_id:
        print("No task_id in response:", data)
        return

    print("Submitted, task_id =", task_id)
    
    start_time = time.time()

    while True:
        if time.time() - start_time > TIMEOUT:
            print("Timeout (seconds)")
            return
        try:
            r = session.get(f"{BASE_URL}/task/result/{task_id}", headers={"Cache-Control":"no-cache"}, timeout=30)
            r.raise_for_status()
            j = r.json()
        except Exception as e:
            print("Polling error:", repr(e))
            time.sleep(1)
            continue

        st = j.get("status", "UNKNOWN")
        print("status:", st)

        if st in ("RUNNING", "QUEUED"):
            time.sleep(1)
            continue

        if st == "SUCCESS":
            print("SUCCESS, result:", json.dumps(j.get("result"), ensure_ascii=False, indent=4))
            return j.get("result")
        elif st == "FAILED":
            print("FAILED:", j.get("error", j))
            return
        elif st == "NOT_FOUND":
            print("NOT_FOUND: maybe invalid or recycled task_id")
            return
        else:
            print("UNKNOWN:", j)
            return

def riskbypass_tls_forward(url, method, headers, data, cookies, proxy, timeout=30):
    if type(data) == str:
        body_base64 = base64.b64encode(data.encode()).decode()
    elif type(data) == bytes:
        body_base64 = base64.b64encode(data).decode()
    elif type(data) == dict:
        network_data = urlencode(data)
        body_base64 = base64.b64encode(network_data.encode()).decode()
    else:
        body_base64 = None
    payload = {
        "task_type": "tls_forward",
        "proxy": proxy,
        "url": url,
        "method": method,
        "headers": headers,
        "body_base64": body_base64,
        "cookies_dict": cookies,
        "timeout": timeout
    }
    result = run_task(payload)
    if not result:
        raise Exception('TLS Forward Error')
    else:
        return RiskbypassResponse(result)
    

class RiskbypassResponse:
    def __init__(self, response_dict):
        # 将字典转换为响应对象
        self.body = base64.b64decode(response_dict.get('body_base64').encode())
        self.cookies = response_dict.get('cookies', {})
        self.elapsed = response_dict.get('elapsed', 0)
        self.error = response_dict.get('error', None)
        self.headers = response_dict.get('headers', {})
        self.ok = response_dict.get('ok', False)
        self.reason = response_dict.get('reason', '')
        self.status_code = response_dict.get('status_code', 0)
        self.text = response_dict.get('text', '')
        self.url = response_dict.get('url', '')
    
    def json(self):
        return json.loads(self.body)


def req(result):
    cookies = {
        'datadome': result.get('datadome')
    }

    headers = {
        'accept': 'application/json',
        'accept-language': 'zh-CN,zh;q=0.9',
        'cache-control': 'no-cache',
        'content-type': 'application/json',
        'origin': 'https://accounts.shutterstock.com',
        'pragma': 'no-cache',
        'priority': 'u=1, i',
        'referer': 'https://accounts.shutterstock.com/login?dd_referrer=',
        'sec-ch-device-memory': '8',
        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
        'sec-ch-ua-arch': '"x86"',
        'sec-ch-ua-full-version-list': '"Google Chrome";v="143.0.7499.170", "Chromium";v="143.0.7499.170", "Not A(Brand";v="24.0.0.0"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-model': '""',
        'sec-ch-ua-platform': '"Windows"',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-origin',
        'user-agent': result.get('ua'),
        'x-end-stck-session-id': 'a478e9ec-8215-4a9c-89f2-d2edd671bdc2',
        'x-end-user-anonymous-id': '8aa478e9-ec82-453a-9c09-f2d2edd671bd',
        'x-newrelic-id': 'XQAAU1VRGwsBU1NUAAY=',
        'x-requested-with': 'XMLHttpRequest',
        'x-shutterstock-otp-supported-login': 'true',
        'x-shutterstock-redirect-supported-login': 'true',
    }

    json_data = {
        'username': '12321567hgf@gmail.com',
        'password': 'sadsadsadaxf',
        'next': '/',
        'g-recaptcha-response': '',
    }
    response = riskbypass_tls_forward(
        url='https://accounts.shutterstock.com/login',
        method='POST',
        cookies=cookies, 
        headers=headers, 
        data=json.dumps(json_data, separators=(',', ':')),
        proxy=PROXY
    )
    return response

if __name__ == "__main__":
    invisible_payload = {
        "task_type":"datadome-invisible",
        "proxy": PROXY,
        "target_url":"https://accounts.shutterstock.com/login?dd_referrer=",
        "datadome_js_url":"https://js.datadome.co/tags.js",
        "ddjskey":"1A1097A806C03451D36605BD91879C",
        "ddoptions":"{\"ajaxListenerPath\": true}"
    }
    result = run_task(invisible_payload)
    response = req(result)
    slider_payload = {
        "task_type": "datadome-slider",
        "proxy": PROXY,
        "target_url": 'https://accounts.shutterstock.com/login',
        "target_method": "POST", 
        "init_cookies": response.cookies
    }
    result = run_task(slider_payload)
    response = req(result)
    print(response.text)

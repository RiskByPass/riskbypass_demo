# -*- coding: utf-8 -*-
# Auto-generated by RiskByPass Task Panel
# Deps: pip install requests
import requests, time, json, random, base64
from urllib.parse import urlencode
from json import dumps as json_dumps
import random

BASE_URL = "https://riskbypass.com"  # API base URL
TOKEN    = "your token"    # Access token (sent as x-api-key)
TIMEOUT  = 60                         # Timeout (seconds)
random_port = random.randint(10000, 20000)
PROXY = f"http://username:password@host:port"
        


def run_task(payload):
    def print(*args, **kwargs):
        pass
    session = requests.Session()
    headers = {"Content-Type": "application/json", "x-api-key": TOKEN}

    print("Submitting task…")

    try:
        resp = session.post(f"{BASE_URL}/task/submit", headers=headers, json=payload, timeout=30)
        resp.raise_for_status()
        data = resp.json()
    except Exception as e:
        print("Submit request error:", repr(e))
        return

    if not data.get("ok"):
        print("Submit failed:", data)
        return

    task_id = data.get("task_id")
    if not task_id:
        print("No task_id in response:", data)
        return

    print("Submitted, task_id =", task_id)
    
    start_time = time.time()

    while True:
        if time.time() - start_time > TIMEOUT:
            print("Timeout (seconds)")
            return
        try:
            r = session.get(f"{BASE_URL}/task/result/{task_id}", headers={"Cache-Control":"no-cache"}, timeout=30)
            r.raise_for_status()
            j = r.json()
        except Exception as e:
            print("Polling error:", repr(e))
            time.sleep(1)
            continue

        st = j.get("status", "UNKNOWN")
        print("status:", st)

        if st in ("RUNNING", "QUEUED"):
            time.sleep(1)
            continue

        if st == "SUCCESS":
            print("SUCCESS, result:", json.dumps(j.get("result"), ensure_ascii=False, indent=4))
            return j.get("result")
        elif st == "FAILED":
            print("FAILED:", j.get("error", j))
            return
        elif st == "NOT_FOUND":
            print("NOT_FOUND: maybe invalid or recycled task_id")
            return
        else:
            print("UNKNOWN:", j)
            return
        
def tls_forward(url, method="GET", headers={}, json={}, data='', cookies={}, proxy=None, timeout=30, proxies={}):
    use_proxy = proxies.get('all') or proxies.get('https') or proxy
    if json:
        data = json_dumps(json, separators=(', ', ':'), ensure_ascii=False)
    if type(data) == str:
        body_base64 = base64.b64encode(data.encode()).decode()
    elif type(data) == bytes:
        body_base64 = base64.b64encode(data).decode()
    elif type(data) == dict:
        network_data = urlencode(data)
        body_base64 = base64.b64encode(network_data.encode()).decode()
    else:
        body_base64 = None
    payload = {
        "task_type": "tls_forward",
        "proxy": use_proxy,
        "url": url,
        "method": method,
        "headers": headers,
        "body_base64": body_base64,
        "cookies_dict": cookies,
        "timeout": timeout
    }
    if headers.get('user-agent'):
        payload['user_agent'] = headers.get('user-agent')
    result = run_task(payload)
    if not result:
        raise Exception('TLS Forward Error')
    else:
        return RiskbypassResponse(result)

def tls_get(url, headers={}, json={}, data='', cookies={}, proxy=None, timeout=30, proxies={}, params={}):
    if isinstance(params, dict) and params:
        urlparams = urlencode(params)
        url += '?' + urlparams
    return tls_forward(url, 'GET', headers, json, data, cookies, proxy, timeout, proxies)


def tls_post(url, headers={}, json={}, data='', cookies={}, proxy=None, timeout=30, proxies={}, params={}):
    if isinstance(params, dict) and params:
        urlparams = urlencode(params)
        url += '?' + urlparams
    return tls_forward(url, 'POST', headers, json, data, cookies, proxy, timeout, proxies)
    

class RiskbypassResponse:
    def __init__(self, response_dict):
        # 将字典转换为响应对象
        self.body = base64.b64decode(response_dict.get('body_base64').encode())
        self.cookies = response_dict.get('cookies', {})
        self.elapsed = response_dict.get('elapsed', 0)
        self.error = response_dict.get('error', None)
        self.headers = response_dict.get('headers', {})
        self.ok = response_dict.get('ok', False)
        self.reason = response_dict.get('reason', '')
        self.status_code = response_dict.get('status_code', 0)
        self.text = response_dict.get('text', '')
        self.url = response_dict.get('url', '')
    
    def json(self):
        return json.loads(self.body)


if __name__ == '__main__':
    headers = {
        'accept': 'application/json, text/plain, */*',
        'accept-language': 'en,zh-CN;q=0.9,zh;q=0.8',
        'authorization': 'Ubi_v1 t=ewogICJ2ZXIiOiAiMSIsCiAgImFpZCI6ICIxMDY4ZWY1Mi1kZmQyLTRlNjItOGFjOS0zN2E0N2U2YzBiNzgiLAogICJlbnYiOiAiUHJvZCIsCiAgInNpZCI6ICIzYzcxNDkxNy1lZmEyLTQ4YTgtOWQ5MS1lMjQyMDY1YjE2MGYiLAogICJ0eXAiOiAiSldFIiwKICAiZW5jIjogIkExMjhDQkMiLAogICJpdiI6ICJnNjd1anhqMUpFY3FqYjd4Vno2bnlnIiwKICAiaW50IjogIkhTMjU2IiwKICAia2lkIjogImRjNjM4OTQ5LTUxYTgtNGI4ZS05NGZkLTQyNzA4MDY5YTBkNiIKfQ.9O9a0TDCRkk4wgVeS6N5aVaCKBNRRRMdS5SDcpagQr2ZVnEEB543itCK7wGSpGGuhnKI1q18j0tFswcbA8xUxT-AS3euVmb_eXQLR-bKJzZUd1JNFpguDmH9hWMDFcw2F8LV-v5P2N2OWTFVFJbldG6IyQkwoaAFbHuRtprDafnqUQXrv8ROPY3fc7cKFAZf6Zmk77ctq1wfEJP5Flc03wDoXDhMRZ8V_4Xb5tLNzkbmL07ek9nvBn-UH0U8sU9cvNw3w3TslBYlaD7brn7qz0gvLaHNwI17Di_araU87WRreXjI16u32kQEv-3vPLxv1UN6oszKwuRJMrK3P3cIm5RUlOVjUlORtjoVXAIR2HhGkwFJtw4Bv_JeKKuFaMD7BuPZNegXJenDVcHMo20_jPIyU9yqv9u_CHoypb39hX3jymtptoznzAQ3GYtdG3fKNN6uLuS_tZz_ISZVoWnRH3Bn01bWyn7aJPXoo9B-nMPl4NGpRMNUoikcH_BStPE13T9HuZwTNM06YJWBfMEsijH0Wq0ZmSVmM48-uJ5gtC6vkcNjQ3vtbz5PJvob11dqSaUAvlV28dT3s3kUnsvrXnVCiYxR8NnKOvrXgtWN2qpht7jYI4Shs1yRrStsOaF08i-L3h5hn7dGsx3M5QvdOWrI2e-WHUh22hQ_MXKRi655uqZBek9rJCatvOX2xTNzEPTFdl-V_-kv0l03SFR1So_V0WYOg0PBglHjRmIouVXscurzQqVEoCleNVZaPlrDdPp9DN9LpEE4__uMNSjcCH-bjqMtDnhkHRuXUxXrfPiqbEkEuzcFnUkC-goNqMDSPTQQWayktf3Dp3_BDzxbQFGDdVPlF626x7ZffChxbwiQpugdjKXl30itlhGuJL18W5MUzFUFqzom_N4Zz2kvt4zRk74oPwcfIHDCr29ETztS7GLnkUsHxbdJscF1bSyKIzFhCAn0L3qS4Hpd_nnjBh6sSFe73l0EM2FS-dcTK9BVEFXYwSxIwFAmYt5BNP6rV5AZZyWRaS08fKlOhXIz9NrwJwp_0HF-IiUot2biQ85HHofX-pXnpIz8ASewdYRN1i7kZ2qpvdnJBL-soF69HKJSHsCp_k0qp6Bzvl7N0r6wCY9VTKkgiMWT4yrJrYET1Th3V3fWvEGpkF38soYM6fXvoKcG0Py6BbHhxMg-kEubfixZFWOynMNqXkHH79Ggf259utM23SMV60LZyW6XMN7EtjnNBRjgRs0JbBjMTE9zdUUJvNTEWePqWJ6Aucz1ar2Pf59xFpsxOGp40qv5xi6dBoR_OOlEgrmojw5vcBnE9vQCU5DPv2wf7EposiAciwwy7k6xN-MIQaxizKHzXQZZWpw0_VMW1ZBPXOp8gGx_fTlBYKtDPellJx-6eryuM4wKlJy3a0m4GjGoByXkiPC_Lz_llNNuCykFK_37QAwGbWL9RXv7Vj8UypljJ2QveXGgkMJbcKQszsf9xQw1O5izC4NCmzxMvdzhA-B8WKZ-HSVD6oVOmOxqVtb4tX7hc8kM5_tnOJ-M3pno3bfFzOko3SqMVyRyuKqLwy6Akr4j5APHhxClII18LRWsmRsthfinZXiLg9K5v1OR5BJzH89U9Mskcx5CTuH5XHdBB9qgbPh02OLEA8dBvdic8exBH21SKJaFXUUAq9HjF_BkFJka98wtxoNX1SDZ_n2xcdyPzhDuzbsE6Apnn4F7ubqB6xNlFX9Xj868XOwVqpdYlaLZtCVIaLulZuxiOZ3W4y7o_BD-9XcmSKMgLxQsuQ6bkE4LpqYQyWpq8lOTX3_jlkqvMPhXqirNhB85KT_zfatGl9SfooReUB8v1wa9kBJAV__vgq05qFsqyyCKaZX0fNp2CvdNk3SXBBuyyOp2Abizo_5oYMhH3szRdXZ2UXYEiw_LbLrmZ0Q-A0EqqRHByA.Rm2ymX1OxSxrzlIU2BqcMzqrxg0Ptn51QjyGLCnKL0c',
        'cache-control': 'no-cache',
        'content-type': 'application/json',
        'origin': 'https://www.ubisoft.com',
        'pragma': 'no-cache',
        'priority': 'u=1, i',
        'sec-ch-ua': '"Not:A-Brand";v="99", "Google Chrome";v="145", "Chromium";v="145"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'cross-site',
        'ubi-appid': '74e71609-1ddf-47da-9073-71ac3aa8c90c',
        'ubi-localecode': 'en-us',
        'ubi-sessionid': '3c714917-efa2-48a8-9d91-e242065b160f',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36',
        # 'x-datadome-clientid': 'BW9qy91F7XAj~FnrDv42Uf~EzEWkFs2MEF2uXT2Pg~PWShr9UcHTTxbJr0HkGepFqPcCSh17OZ9u7tjyZImQy6~odqlhnlmq2IZEvjCfthU9fCz4w6NXBPQSt5Vcw8U7',
    }

    json_data = {
        'email': 'a1796932792@gmail.com',
        'password': 'Zong17969qwe123.',
        'resetKey': 'A3E2CA0948B9819E83F733A02A8C6FF9E429507173136F4F9429EDD6C42094BDEA392552A80947FC598E0C790AC9367E5C976E63C10EE6E700E77E0396D76D05',
    }

    response = tls_post('https://public-ubiservices.ubi.com/v3/users/completeResetPassword', headers=headers, json=json_data, proxy=PROXY)
    print(response.status_code)
    print(response.text)

    if response.status_code == 403:
        captcha_url = response.json()['url']
        dd_payload = {
            "task_type": "datadome-slider",
            "proxy": PROXY,
            "target_url": captcha_url,
            "target_method": "GET",
            "init_cookies": response.cookies
        }
        dd_result = run_task(dd_payload)
        datadome = dd_result.get('datadome')
        headers['x-datadome-clientid'] = datadome
        response = tls_post('https://public-ubiservices.ubi.com/v3/users/completeResetPassword', headers=headers, json=json_data, proxy=PROXY)
        print(response.status_code)
        print(response.text)